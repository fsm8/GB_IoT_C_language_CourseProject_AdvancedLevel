#define _CRT_SECURE_NO_WARNINGS

#include "functions.h"
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

float f1(float x) // функция 1
{
	return (0.6 * x) + 3;
}

float f2(float x) // функция 2
{
	return pow((x - 2), 3) - 1;
}

float f3(float x) // функция 3
{
	return 3 / x;
}

/// Опции командной строки
void cmd(int argc, char* argv[], int* a, int* b, int* c, float* eps1)
{
	for (int i = 0; i < argc; i++) // считываем ключи командной строки
	{
		if (strcmp(argv[i], "-help") == 0) // если введен ключ -help
		{
			printf("Консольное приложение для расчета площади фигуры, образованной кривыми трех функций.\n\n");

			printf("Расчет проводится в два этапа:\n");
			printf("а) расчет точек пересечения функций в положительной области оси абсцисс,\n");
			printf("б) расчет площади фигуры, образованной кривыми трех функций.\n\n");

			printf("Список поддерживаемых программой ключей:\n");
			printf("1. -help - список ключей, которые обрабатывает данное приложение и их назначение.\n");
			printf("2. -a - печатаются абсциссы точек пересечения кривых.\n");
			printf("3. -iter - печатается число итераций, потребовавшихся на приближённое решение уравнений при поиске точек пересечения.\n");
			printf("4. -sqr - печатается площадь фигур под кривыми функций f1, f2, f3.\n");
			printf("5. -eps1 - ввод точности (в формате 0,001) при поиске точек пересечения. Максимум 100 цифр. По-умолчанию eps1 = 0,001\n");
		}

		if (strcmp(argv[i], "-a") == 0)
		{
			*a = 1; // ставим флаг по ключу командной строки на печать абсцисс точек пересечения кривых
		}

		if (strcmp(argv[i], "-iter") == 0)
		{
			*b = 1; // ставим флаг по ключу командной строки на печать числа итераций
		}

		if (strcmp(argv[i], "-sqr") == 0)
		{
			*c = 1; // ставим флаг по ключу командной строки на печать площадей фигур под кривыми функций f1, f2, f3
		}

		if (strcmp(argv[i], "-eps1") == 0)
		{
			// Защита от падения программы при отсутствии значения точности после ключа
			char s[102] = { 0 }; // строка в которую копируем значения после ключа
			int brk = 0; // переменная для проверки ключа

			if (i != argc - 1) // если ключ не является последним в списке аргументов
			{
				strncpy(s, argv[i + 1], 100); // копируем значения после ключа для его проверки

				if (s[0] >= '0' && s[0] <= '9') // Проверка на наличие значения после ключа. Истина
				{
					printf("\nВы ввели eps1: %f\n", strtof(argv[i + 1], NULL)); // Вывод на экран принятого числа
					if (strtof(argv[i + 1], NULL)) // если в числе точка, а strtof переводит во float до точки, то не даем отдать в расчет ноль
					{
						*eps1 = strtof(argv[i + 1], NULL); // преобразуем строку в значение типа float
					}
				}
				else  // Проверка на наличие значения после ключа. Ложь
				{
					printf("\nВы не ввели число или формат неверен!\n");
					continue;
				}
			}
			else // ключ является последним в списке аргументов
			{
				printf("\nВы не ввели число или формат неверен!\n");
			}
		}
	}
}

/// Вычисление корней уравнения линейным поиском (rootFindLineSearch)
float root(float xl, float xr, float eps1, int* stepcount, function f, function f2)
{
	float x, minx = xl, nextstep;
	nextstep = fabs(xr - xl) / (10 / eps1); //разбиваем интервал на отрезки 
	*stepcount = 0;
	for (x = xl; x < xr; x += nextstep, (*stepcount)++)
	{

		if ((fabs(f(x)) - (fabs(f2(x)))) <= eps1)
		{
			minx = x;
		}
	}
	return minx;
}

/// Вычисление интеграла методом прямоугольника (calcIntegralSquare)
float integral(float xl, float xr, int eps2, function f)
{
	float sum = 0;
	float h = (xr - xl) / eps2; // ширина единичного отрезка, или шаг интегрирования
	for (int i = 0; i < eps2; i++)
	{
		sum = sum + f(xl); // складываем величины высот интегрируемой фигуры
		xl += h;
	}
	return sum * h; // умножаем сумму величин высот интегрируемой фигуры на ширину единичного отрезка
}

/// Печать абсцисс точек пересечения кривых и число итераций, потребовавшихся на приближённое решение уравнений при поиске точек пересечения
void printing(int a, int b, float point, int stepcount, char strP)
{
	if (a) // если установлен флаг по ключу командной строки на печать абсциссы точек пересечения кривых, то печатаем их
	{
		if (strP == 'C')
		{
			printf("\n");
			printf("________________Результаты расчета__________________\n");
			printf("Абсциссы точек пересечения кривых:\n");
		}
		printf("Точка %c = %f ", strP, point); // печатаем точку пересечения кривых функций в положительной области оси абсцисс
		if (!b)
		{
			printf("\n");
		}
	}
	if (b) // если установлен флаг по ключу командной строки на печать числа итераций, то печатаем их
	{
		printf("Корень найден за %d итераций \n", stepcount);
	}
}